\section{Detailed Module Design}
\label{sec:detailed_module_design}


% Subsection for Input/Output Controller
\subsection{Input/Output Controller}
\label{subsec:io_controller}

The \texttt{input\_output\_controller} module is responsible for managing user inputs and displaying the corresponding outputs on a 7-segment display. It processes raw button inputs, debounces them, detects rising edges, and converts the input values into a format suitable for further processing. The module also handles the display of the current input value on the 7-segment display.

\subsubsection{Inputs and Outputs}
The inputs and outputs of the module are described in Table~\ref{tab:io_controller_interface}.

\begin{table}[H]
\centering
\caption{Input/Output Controller Interface}
\label{tab:io_controller_interface}
\begin{tabular}{|c|c|c|p{8cm}|}
\hline
\textbf{Signal Name} & \textbf{Direction} & \textbf{Width} & \textbf{Description} \\ \hline
\texttt{clk}         & Input              & 1              & Clock signal for synchronization. \\ \hline
\texttt{rst}         & Input              & 1              & Reset signal to initialize the module. \\ \hline
\texttt{btn\_left}    & Input              & 1              & Raw button input for left navigation. \\ \hline
\texttt{btn\_right}   & Input              & 1              & Raw button input for right navigation. \\ \hline
\texttt{btn\_up}      & Input              & 1              & Raw button input for incrementing the value. \\ \hline
\texttt{btn\_down}    & Input              & 1              & Raw button input for decrementing the value. \\ \hline
\texttt{btn\_mid}     & Input              & 1              & Raw button input for confirming the input. \\ \hline
\texttt{reset\_input} & Input              & 1              & Signal to reset the input controller. \\ \hline
\texttt{seg}          & Output             & 7              & 7-segment display output. \\ \hline
\texttt{an}           & Output             & 4              & 7-segment display anode control. \\ \hline
\texttt{input\_val}   & Output             & 16 & Packed input value. \\ \hline
\texttt{input\_done}  & Output             & 1              & Signal indicating that the input is complete. \\ \hline
\end{tabular}
\end{table}

\subsubsection{Flowchart}
The flow of the \texttt{input\_output} module is illustrated in Figure~\ref{fig:input_output_flowchart}.
    
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/input.png}
\caption{Flowchart of the Input/Output Module}
\label{fig:input_output_flowchart}
\end{figure}


\subsubsection{Block Diagram and Operation}

The block diagram of the \texttt{input\_output} module is illustrated in Figure~\ref{fig:input_output_sch}.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/input_sch.png}
\caption{Block Diagram of the Input/Output Module}
\label{fig:input_output_sch}
\end{figure}

\noindent
The \texttt{input\_output\_controller} module consists of the following submodules:
\begin{itemize}
    \item \textbf{Clock Divider:} Generates a slower clock signal (100 MHz) from the system clock (300 MHz) for use in the input controller.
    \item \textbf{Debouncers:} Debounces the raw button inputs to ensure stable signals. Each button input is debounced using a 2 ms debounce time.
    \item \textbf{Edge Detectors:} Detects rising edges of the debounced button signals to trigger specific actions.
    \item \textbf{Input Controller:} Manages the user input process, including navigation between digits, incrementing/decrementing values, and confirming the input. The current input value is packed into \texttt{input\_val}.
    \item \textbf{Output Controller:} Drives the 7-segment display to show the current input value. The display updates smoothly using the fast clock.
\end{itemize}

% \subsubsection{Flowchart}
% The flow of the \texttt{input\_output\_controller} module is illustrated in Figure~\ref{fig:io_controller_flowchart}.

% \begin{figure}[H]
% \centering
% \includegraphics[width=\textwidth]{images/io_controller_flowchart.pdf}
% \caption{Flowchart of the Input/Output Controller Module}
% \label{fig:io_controller_flowchart}
% \end{figure}

\noindent The module operates as follows:
\begin{enumerate}
    \item The clock divider generates a slower clock signal for the input controller.
    \item Raw button inputs are debounced to ensure stable signals.
    \item Rising edges of the debounced signals are detected to trigger specific actions.
    \item The input controller processes the button signals to update the input value and signals when the input is complete.
    \item The output controller drives the 7-segment display to show the current input value.
\end{enumerate}

\noindent The module ensures robust handling of user inputs and provides a clear visual representation of the input value on the 7-segment display.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



% Subsection for Display Controller
\newpage 
\subsection{Display Controller}
\label{subsec:display_controller}

The \texttt{display\_controller} module is responsible for decoding and displaying the result of computations on a 7-segment display. It converts the BFloat16 (BF16) result into a human-readable decimal format, handles error signaling, and supports scrolling for long numbers.

\subsubsection{Inputs and Outputs}
The inputs and outputs of the module are described in Table~\ref{tab:display_controller_interface}.

\begin{table}[H]
\centering
\caption{Display Controller Interface}
\label{tab:display_controller_interface}
\begin{tabular}{|c|c|c|p{8cm}|}
\hline
\textbf{Signal Name} & \textbf{Direction} & \textbf{Width} & \textbf{Description} \\ \hline
\texttt{clk}         & Input              & 1              & Clock signal for synchronization. \\ \hline
\texttt{rst}         & Input              & 1              & Reset signal to initialize the module. \\ \hline
\texttt{result}      & Input              & 16 & BF16 result to be displayed. \\ \hline
\texttt{error}       & Input              & 1              & Error flag indicating invalid computation. \\ \hline
\texttt{start}       & Input              & 1              & Start signal indicating that the result is ready. \\ \hline
\texttt{seg}         & Output             & 7              & 7-segment display output. \\ \hline
\texttt{an}          & Output             & 4              & 7-segment display anode control. \\ \hline
\texttt{led}         & Output             & 16             & LED indicators for debugging or status. \\ \hline
\texttt{dp}          & Output             & 1              & Decimal point control for the 7-segment display. \\ \hline
\end{tabular}
\end{table}

\subsubsection{Flowchart}
The flow of the \texttt{display} module is illustrated in Figure~\ref{fig:display_flowchart}.
    
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/display.png}
\caption{Flowchart of the Display Module}
\label{fig:display_flowchart}
\end{figure}


\subsubsection{Block Diagram and Operation}

The block diagram of the \texttt{display} module is illustrated in Figure~\ref{fig:display_sch}.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/display_sch.png}
\caption{Block Diagram of the Display Module}
\label{fig:display_sch}
\end{figure}

\noindent
The \texttt{display\_controller} module operates in the following stages:
\begin{itemize}
    \item \textbf{BF16 Decoding:} The BF16 result is decoded into its sign, exponent, and mantissa fields. The exponent is adjusted using a bias of 127, and the mantissa is normalized to construct the fixed-point representation.
    \item \textbf{Magnitude Calculation:} The module computes the absolute value of the result and applies the sign bit to determine the signed magnitude.
    \item \textbf{Integer and Fraction Extraction:} The integer and fractional parts of the result are extracted. The fractional part is scaled to ensure sufficient precision for display.
    \item \textbf{Decimal Conversion:} The integer and fractional parts are converted into decimal digits. Up to 5 integer digits and 8 fractional digits are supported.
    \item \textbf{Symbol Construction:} The module constructs a stream of symbols, including the sign, integer digits, and fractional digits. A decimal point is inserted after the least significant integer digit if fractional digits are present.
    \item \textbf{Windowing and Scrolling:} For long numbers, the module supports scrolling across multiple windows. Each window displays up to 4 symbols at a time, and the display scrolls automatically at a fixed interval.
    \item \textbf{7-Segment Encoding:} The symbols are encoded into 7-segment display patterns. Special symbols such as '-' (negative sign) and 'E' (error) are also supported.
    \item \textbf{Multiplexing:} The module uses a multiplexing scheme to drive the 7-segment display, refreshing each digit at a high frequency to ensure smooth display.
\end{itemize}

% \subsubsection{Flowchart}
% The flow of the \texttt{display\_controller} module is illustrated in Figure~\ref{fig:display_controller_flowchart}.

% \begin{figure}[H]
% \centering
% \includegraphics[width=\textwidth]{images/display_controller_flowchart.pdf}
% \caption{Flowchart of the Display Controller Module}
% \label{fig:display_controller_flowchart}
% \end{figure}

\noindent The module ensures accurate and user-friendly display of results, with robust handling of errors and support for long numbers through scrolling. The use of pipelined stages and multiplexing ensures efficient operation and smooth display updates.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% Subsection for Addition
\newpage 
\subsection{Addition}
\label{subsec:addition}

The \texttt{add} module is designed to perform signed integer addition of two 16-bit inputs and output the result in BFloat16 (BF16) format. The module ensures accurate computation and handles overflow conditions gracefully. With the addition of an \texttt{add\_sub\_flag}, the module can also perform subtraction when the flag is set.

\subsubsection{Inputs and Outputs}
The inputs and outputs of the module are described in Table~\ref{tab:add_interface}.

\begin{table}[H]
\centering
\caption{Addition Module Interface}
\label{tab:add_interface}
\begin{tabular}{|c|c|c|p{8cm}|}
\hline
\textbf{Signal Name} & \textbf{Direction} & \textbf{Width} & \textbf{Description} \\ \hline
\texttt{clk}         & Input              & 1              & Clock signal for synchronization. \\ \hline
\texttt{rst}         & Input              & 1              & Reset signal to initialize the module. \\ \hline
\texttt{start}       & Input              & 1              & Start signal to initiate the computation. \\ \hline
\texttt{a}           & Input              & 16             & Signed integer input. \\ \hline
\texttt{b}           & Input              & 16             & Signed integer input. \\ \hline
\texttt{add\_sub\_flag} & Input              & 1              & Flag to indicate addition (0) or subtraction (1). \\ \hline
\texttt{result}      & Output             & 16             & The computed sum in BFloat16 format. \\ \hline
\texttt{done}        & Output             & 1              & A signal indicating that the computation is complete. \\ \hline
\texttt{error}       & Output             & 1              & A flag indicating if an overflow occurred during computation. \\ \hline
\end{tabular}
\end{table}

\subsubsection{Flowchart}
The flow of the \texttt{add} module is illustrated in Figure~\ref{fig:add_flowchart}.
    
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/add.png}
\caption{Flowchart of the Addition Module}
\label{fig:add_flowchart}
\end{figure}


\subsubsection{Block Diagram and Operation}

The block diagram of the \texttt{add} module is illustrated in Figure~\ref{fig:add_sch}.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/add_sch.png}
\caption{Block Diagram of the Addition Module}
\label{fig:add_sch}
\end{figure}

\noindent
The \texttt{add} module operates in the following stages:
\begin{enumerate}
    \item \textbf{Input Validation:} The module checks the validity of the inputs and ensures that the reset signal is deasserted before proceeding.
    \item \textbf{Addition:} The signed 16-bit inputs are added using a hardware adder. The raw sum is computed, and the overflow condition is checked.
    \item \textbf{Subtraction Handling:} If the \texttt{add\_sub\_flag} is set, the module will first negate the second input \texttt{b} before performing the addition, effectively computing \texttt{a - b}.
    \item \textbf{BF16 Conversion:} The raw sum is normalized and converted into BF16 format, including the sign, exponent, and mantissa fields.
    \item \textbf{Output:} The \texttt{done} signal is asserted to indicate that the computation is complete, and the result is made available on the output.
\end{enumerate}


\noindent The module handles both addition and subtraction of signed integers, with robust handling of overflow conditions and conversion to BF16 format.

% Subsection for Subtraction
% \newpage 
% \subsection{Subtraction}
% \label{subsec:subtraction}

% The \texttt{sub} module is designed to perform signed integer subtraction of two 16-bit inputs and output the result in BFloat16 (BF16) format. The module ensures accurate computation and handles underflow conditions gracefully.

% \subsubsection{Inputs and Outputs}
% The inputs and outputs of the module are described in Table~\ref{tab:sub_interface}.

% \begin{table}[H]
% \centering
% \caption{Subtraction Module Interface}
% \label{tab:sub_interface}
% \begin{tabular}{|c|c|c|p{8cm}|}
% \hline
% \textbf{Signal Name} & \textbf{Direction} & \textbf{Width} & \textbf{Description} \\ \hline
% \texttt{clk}         & Input              & 1              & Clock signal for synchronization. \\ \hline
% \texttt{rst}         & Input              & 1              & Reset signal to initialize the module. \\ \hline
% \texttt{start}       & Input              & 1              & Start signal to initiate the computation. \\ \hline
% \texttt{a}           & Input              & 16             & Signed integer input. \\ \hline
% \texttt{b}           & Input              & 16             & Signed integer input. \\ \hline
% \texttt{result}      & Output             & 16             & The computed difference in BFloat16 format. \\ \hline
% \texttt{done}        & Output             & 1              & A signal indicating that the computation is complete. \\ \hline
% \texttt{error}       & Output             & 1              & A flag indicating if an underflow occurred during computation. \\ \hline
% \end{tabular}
% \end{table}

% \subsubsection{Block Diagram and Operation}
% The \texttt{sub} module operates in the following stages:
% \begin{enumerate}
%     \item \textbf{Input Validation:} The module checks the validity of the inputs and ensures that the reset signal is deasserted before proceeding.
%     \item \textbf{Subtraction:} The signed 16-bit inputs are subtracted using a hardware subtractor. The raw difference is computed, and the underflow condition is checked.
%     \item \textbf{Underflow Handling:} If an underflow occurs, the \texttt{error} signal is asserted, and the result is set to the minimum representable value in BF16 format.
%     \item \textbf{BF16 Conversion:} The raw difference is normalized and converted into BF16 format, including the sign, exponent, and mantissa fields.
%     \item \textbf{Output:} The \texttt{done} signal is asserted to indicate that the computation is complete, and the result is made available on the output.
% \end{enumerate}

% \subsubsection{Flowchart}
% The flow of the \texttt{sub} module is illustrated in Figure~\ref{fig:sub_flowchart}.

% \begin{figure}[H]
% \centering
% \includegraphics[width=\textwidth]{images/sub_flowchart.pdf}
% \caption{Flowchart of the Subtraction Module}
% \label{fig:sub_flowchart}
% \end{figure}

% \noindent The module ensures efficient and accurate subtraction of signed integers, with robust handling of underflow conditions and conversion to BF16 format.

% Subsection for Multiplication
\newpage 
\subsection{Multiplication}
\label{subsec:multiplication}

The \texttt{mul} module is a pipelined arithmetic unit designed to perform signed integer multiplication on two inputs (\texttt{a} and \texttt{b}) and automatically convert the resulting product into the BFloat16 (BF16) floating-point format.

\subsubsection{Inputs and Outputs}
The inputs and outputs of the module are described in Table~\ref{tab:mul_interface}.

\begin{table}[H]
\centering
\caption{Multiplication Module Interface}
\label{tab:mul_interface}
\begin{tabular}{|c|c|c|p{8cm}|}
\hline
\textbf{Signal Name} & \textbf{Direction} & \textbf{Width} & \textbf{Description} \\ \hline
\texttt{clk}         & Input              & 1              & Clock signal for synchronization. \\ \hline
\texttt{rst}         & Input              & 1              & Reset signal to initialize the module. \\ \hline
\texttt{start}       & Input              & 1              & Start signal to initiate the computation. \\ \hline
\texttt{a}           & Input              & 16             & Signed integer input. \\ \hline
\texttt{b}           & Input              & 16             & Signed integer input. \\ \hline
\texttt{result}      & Output             & 16             & The computed product in BFloat16 format. \\ \hline
\texttt{done}        & Output             & 1              & A signal indicating that the computation is complete. \\ \hline
\texttt{error}       & Output             & 1              & A flag indicating if an error occurred during computation. \\ \hline
\end{tabular}
\end{table}

\subsubsection{Flowchart}
The flow of the \texttt{mul} module is illustrated in Figure~\ref{fig:mul_flowchart}.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/mul.png}
\caption{Flowchart of the Multiplication Module}
\label{fig:mul_flowchart}
\end{figure}


\subsubsection{Block Diagram and Operation}

The block diagram of the \texttt{mul} module is illustrated in Figure~\ref{fig:mul_sch}.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/mul_sch.png}
\caption{Block Diagram of the Multiplication Module}
\label{fig:mul_sch}
\end{figure}

\noindent The multiplication module operates through a four-stage pipeline to convert signed integer inputs into a BFloat16 format. The stages are described as follows:
\begin{enumerate}
    \item \textbf{Stage 1:} Perform a signed 16×16 multiplication to generate a raw 32-bit product.
    \item \textbf{Stage 2:} Extract the sign bit and compute the absolute value of the product to facilitate downstream normalization.
    \item \textbf{Stage 3:} Use a priority encoder to determine the position of the leading '1' bit within the magnitude.
    \item \textbf{Stage 4:} Construct the 16-bit BF16 result by calculating the exponent using a bias of 127 and extracting the required 7-bit mantissa. At this stage, the \texttt{done} signal is asserted to indicate valid output.
\end{enumerate}

\noindent The module also includes error handling to ensure that invalid inputs or computation errors are flagged appropriately.
% Subsection for Division
\newpage 
\subsection{Division}
\label{subsec:division}

The \texttt{div} module is a sequential hardware divider using the Restoring Division algorithm (Reference: \url{https://www.geeksforgeeks.org/computer-organization-architecture/restoring-division-algorithm-unsigned-integer/}). It is designed to divide two signed integers and output the result in BF16 format. The module utilizes a Finite State Machine (FSM) to manage the calculation stages, transitioning from initialization to integer division, fractional division, and finally output formatting.

\subsubsection{Inputs and Outputs}
The inputs and outputs of the module are described in Table~\ref{tab:div_interface}.

\begin{table}[H]
\centering
\caption{Division Module Interface}
\label{tab:div_interface}
\begin{tabular}{|c|c|c|p{8cm}|}
\hline
\textbf{Signal Name} & \textbf{Direction} & \textbf{Width} & \textbf{Description} \\ \hline
\texttt{clk}         & Input              & 1              & Clock signal for synchronization. \\ \hline
\texttt{rst}         & Input              & 1              & Reset signal to initialize the module. \\ \hline
\texttt{start}       & Input              & 1              & Start signal to initiate the computation. \\ \hline
\texttt{a}           & Input              & 16             & Signed integer input. \\ \hline
\texttt{b}           & Input              & 16             & Signed integer input. \\ \hline
\texttt{result}      & Output             & 16             & The computed quotient in BFloat16 format. \\ \hline
\texttt{done}        & Output             & 1              & A signal indicating that the computation is complete. \\ \hline
\texttt{error}       & Output             & 1              & A flag indicating if an error occurred during computation (e.g., division by zero). \\ \hline
\end{tabular}
\end{table}

\subsubsection{Flowchart}
The flow of the \texttt{div} module is illustrated in Figure~\ref{fig:div_flowchart}.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/div.png}
\caption{Flowchart of the Division Module}
\label{fig:div_flowchart}
\end{figure}

\subsubsection{Block Diagram and Operation}

The block diagram of the \texttt{div} module is illustrated in Figure~\ref{fig:div_sch}.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/div_sch.png}
\caption{Block Diagram of the Division Module}
\label{fig:div_sch}
\end{figure}

\noindent The \texttt{div} module executes a four-stage finite state machine to convert signed integers into BFloat16 format. The stages are described as follows:
\begin{enumerate}
    \item \textbf{Initialization (S\_IDLE):} The system checks for division-by-zero errors, determines the result's sign, and converts inputs into absolute values, as the Restoring Division algorithm operates on unsigned integers.
    \item \textbf{Integer Division (S\_INTDIV):} The module uses the Restoring Division algorithm to calculate the whole number portion of the quotient.
    \item \textbf{Fractional Division (S\_FRACTIONDIV):} To capture sufficient precision for the floating-point mantissa, the operation continues for an additional eight cycles to generate fractional bits.
    \item \textbf{Normalization and Packing (S\_OUTPUT):} The integer and fractional parts are concatenated and normalized by detecting the leading '1'. The biased exponent is computed, the 7-bit mantissa is extracted, and the components are packed into the final 16-bit register. The \texttt{done} signal is then asserted to indicate valid output.
\end{enumerate}

\noindent The module also includes error handling to ensure that invalid inputs, such as division by zero, are flagged appropriately.

% Subsection for Square Root
\newpage 
\subsection{Square Root}
\label{subsec:square_root}

The \texttt{sqrt} module is designed to compute the square root of a signed 16-bit integer and output the result in BFloat16 (BF16) floating-point format. It avoids using complex IP cores or DSP slices by implementing a hardware-efficient restoring binary square root algorithm (Reference: \url{https://en.wikipedia.org/wiki/Square_root_algorithms#Binary_numeral_system_(base_2)}).

\subsubsection{Inputs and Outputs}
The inputs and outputs of the module are described in Table~\ref{tab:sqrt_interface}.

\begin{table}[H]
\centering
\caption{Square Root Module Interface}
\label{tab:sqrt_interface}
\begin{tabular}{|c|c|c|p{8cm}|}
\hline
\textbf{Signal Name} & \textbf{Direction} & \textbf{Width} & \textbf{Description} \\ \hline
\texttt{clk}         & Input              & 1              & Clock signal for synchronization. \\ \hline
\texttt{rst}         & Input              & 1              & Reset signal to initialize the module. \\ \hline
\texttt{start}       & Input              & 1              & Start signal to initiate the computation. \\ \hline
\texttt{a}           & Input              & 16             & Signed integer input. \\ \hline
\texttt{result}      & Output             & 16             & The computed square root in BFloat16 format. \\ \hline
\texttt{done}        & Output             & 1              & A signal indicating that the computation is complete. \\ \hline
\texttt{error}       & Output             & 1              & A flag indicating if an error occurred during computation (e.g., invalid input). \\ \hline
\end{tabular}
\end{table}

\subsubsection{Flowchart}
The flow of the \texttt{sqrt} module is illustrated in Figure~\ref{fig:sqrt_flowchart}.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/sqrt.png}
\caption{Flowchart of the Square Root Module}
\label{fig:sqrt_flowchart}
\end{figure}

\subsubsection{Block Diagram and Operation}

The block diagram of the \texttt{sqrt} module is illustrated in Figure~\ref{fig:sqrt_sch}.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/sqrt_sch.png}
\caption{Flowchart of the Square Root Module}
\label{fig:sqrt_sch}
\end{figure}
\noindent 

The \texttt{sqrt} module operates through a five-state Finite State Machine (FSM). The stages are described as follows:
\begin{enumerate}
    \item \textbf{S\_IDLE:} The module waits for a \texttt{start} signal to begin computation.
    \item \textbf{S\_PREPARATION:} The module validates the input and scales the operand by $2^{16}$ to ensure sufficient fractional precision.
    \item \textbf{S\_CALCULATION:} The core computation is performed using a digit-by-digit binary square root algorithm. Over 16 iterations, the algorithm constructs the result bit-by-bit.
    \item \textbf{S\_NORM:} The fixed-point output is converted to BFloat16 format. A Count Leading Zeros (CLZ) function is used to derive the exponent, calculated as $134 - \text{clz\_val}$. The mantissa is then normalized.
    \item \textbf{S\_DONE:} The module signals the availability of the result via the \texttt{done} flag.
\end{enumerate}

\noindent The module also includes error handling to ensure that invalid inputs, such as negative numbers, are flagged appropriately.

% Subsection for Cosine
\newpage 
\subsection{Cosine}
\label{subsec:cosine}

The \texttt{cos} module is designed to compute the cosine of an input angle in degrees, using the CORDIC algorithm. The module supports integer inputs in the range [-999, 999] and outputs the result in BFloat16 (BF16) format. The implementation is optimized for hardware efficiency and high performance on resource-constrained FPGAs.

\subsubsection{Inputs and Outputs}
The inputs and outputs of the module are described in Table~\ref{tab:cos_interface}.

\begin{table}[H]
\centering
\caption{Cosine Module Interface}
\label{tab:cos_interface}
\begin{tabular}{|c|c|c|p{8cm}|}
\hline
\textbf{Signal Name} & \textbf{Direction} & \textbf{Width} & \textbf{Description} \\ \hline
\texttt{clk}         & Input              & 1              & Clock signal for synchronization. \\ \hline
\texttt{rst}         & Input              & 1              & Reset signal to initialize the module. \\ \hline
\texttt{start}       & Input              & 1              & Start signal to initiate the computation. \\ \hline
\texttt{a}           & Input              & 16             & Signed integer input representing the angle in degrees. \\ \hline
\texttt{result}      & Output             & 16             & The computed cosine value in BF16 format. \\ \hline
\texttt{done}        & Output             & 1              & A signal indicating that the computation is complete. \\ \hline
\texttt{error}       & Output             & 1              & A flag indicating if an error occurred during computation. \\ \hline
\end{tabular}
\end{table}

\subsubsection{Flowchart}
The flow of the \texttt{cos} module is illustrated in Figure~\ref{fig:cos_flowchart}.
    
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/cos.png}
\caption{Flowchart of the Cosine Module}
\label{fig:cos_flowchart}
\end{figure}


\subsubsection{Block Diagram and Operation}

The block diagram of the \texttt{cos} module is illustrated in Figure~\ref{fig:cos_sch}.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/cos_sch.png}
\caption{Block Diagram of the Cosine Module}
\label{fig:cos_sch}
\end{figure}

\noindent
The \texttt{cos} module operates in the following stages:
\begin{enumerate}
    \item \textbf{Angle Processing:} The input angle is mapped to the range [-90°, 90°] using modular arithmetic. The angle is then converted from degrees to radians in Q2.14 fixed-point format.
    \item \textbf{CORDIC Core:} The Q2.14 radian input is processed using the CORDIC algorithm in rotation mode. The algorithm performs 11 iterations to compute the cosine value with a relative error of approximately 5\%.
    \item \textbf{Output Conversion:} The Q2.14 cosine result is converted to BF16 format. The conversion includes normalization, mantissa extraction, and exponent calculation.
\end{enumerate}

% \subsubsection{Flowchart}
% The flow of the \texttt{cos} module is illustrated in Figure~\ref{fig:cos_flowchart}.

% \begin{figure}[H]
% \centering
% \includegraphics[width=\textwidth]{images/cos_flowchart.pdf}
% \caption{Flowchart of the Cosine Module}
% \label{fig:cos_flowchart}
% \end{figure}

\noindent The module ensures efficient and accurate computation of cosine values, with robust handling of input errors and conversion to BF16 format.


% Subsection for Arccosine
\newpage 
\subsection{Arccosine}
\label{subsec:arccosine}

The \texttt{arccos} module computes the arccosine of an input integer slope in the range [-1, 1] and outputs the result in BFloat16 (BF16) format. The module uses a simple if-else structure to handle the limited input cases, ensuring efficient computation.

\subsubsection{Inputs and Outputs}
The inputs and outputs of the module are described in Table~\ref{tab:arccos_interface}.

\begin{table}[H]
\centering
\caption{Arccosine Module Interface}
\label{tab:arccos_interface}
\begin{tabular}{|c|c|c|p{8cm}|}
\hline
\textbf{Signal Name} & \textbf{Direction} & \textbf{Width} & \textbf{Description} \\ \hline
\texttt{clk}         & Input              & 1              & Clock signal for synchronization. \\ \hline
\texttt{rst}         & Input              & 1              & Reset signal to initialize the module. \\ \hline
\texttt{start}       & Input              & 1              & Start signal to initiate the computation. \\ \hline
\texttt{a}           & Input              & 16             & Signed integer input slope. \\ \hline
\texttt{result}      & Output             & 16             & The computed arccosine in BF16 format. \\ \hline
\texttt{done}        & Output             & 1              & A signal indicating that the computation is complete. \\ \hline
\texttt{error}       & Output             & 1              & A flag indicating if the input is invalid. \\ \hline
\end{tabular}
\end{table}

\subsubsection{Flowchart}
The flow of the \texttt{arccos} module is illustrated in Figure~\ref{fig:arccos_flowchart}.
    
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/arccos.png}
\caption{Flowchart of the Arccosine Module}
\label{fig:arccos_flowchart}
\end{figure}


\subsubsection{Block Diagram and Operation}

The block diagram of the \texttt{arccos} module is illustrated in Figure~\ref{fig:arccos_sch}.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/arccos_sch.png}
\caption{Block Diagram of the Arccosine Module}
\label{fig:arccos_sch}
\end{figure}

\noindent
The \texttt{arccos} module operates as follows:
\begin{enumerate}
    \item \textbf{Input Validation:} The module checks if the input slope is within the valid range [-1, 1]. If the input is out of range, the \texttt{error} signal is asserted, and the result is set to NaN.
    \item \textbf{Special Cases:} The module directly returns precomputed BF16 values for the following cases:
    \begin{itemize}
        \item $\texttt{a} = -1$: $\arccos(-1) = 180^\circ$
        \item $\texttt{a} = 0$: $\arccos(0) = 90^\circ$
        \item $\texttt{a} = 1$: $\arccos(1) = 0^\circ$
    \end{itemize}
    \item \textbf{Output:} The \texttt{done} signal is asserted to indicate that the computation is complete, and the result is made available on the output.
\end{enumerate}

% \subsubsection{Flowchart}
% The flow of the \texttt{arccos} module is illustrated in Figure~\ref{fig:arccos_flowchart}.

% \begin{figure}[H]
% \centering
% \includegraphics[width=\textwidth]{images/arccos_flowchart.pdf}
% \caption{Flowchart of the Arccosine Module}
% \label{fig:arccos_flowchart}
% \end{figure}

\noindent The module ensures efficient and accurate computation of arccosine values for the limited input cases, with robust handling of invalid inputs.


% Subsection for Sine
\newpage 
\subsection{Sine}
\label{subsec:sine}

The \texttt{sin} module computes the sine of an input angle in degrees by reusing the \texttt{cos} module at the ALU level. This is achieved using the trigonometric identity:
\[
\sin(x) = \cos(90^\circ - x)
\]

\subsubsection{Inputs and Outputs}
The inputs and outputs of the module are described in Table~\ref{tab:sin_interface}.

\begin{table}[H]
\centering
\caption{Sine Module Interface}
\label{tab:sin_interface}
\begin{tabular}{|c|c|c|p{8cm}|}
\hline
\textbf{Signal Name} & \textbf{Direction} & \textbf{Width} & \textbf{Description} \\ \hline
\texttt{clk}         & Input              & 1              & Clock signal for synchronization. \\ \hline
\texttt{rst}         & Input              & 1              & Reset signal to initialize the module. \\ \hline
\texttt{start}       & Input              & 1              & Start signal to initiate the computation. \\ \hline
\texttt{a}           & Input              & 16             & Signed integer input representing the angle in degrees. \\ \hline
\texttt{result}      & Output             & 16             & The computed sine value in BF16 format. \\ \hline
\texttt{done}        & Output             & 1              & A signal indicating that the computation is complete. \\ \hline
\texttt{error}       & Output             & 1              & A flag indicating if an error occurred during computation. \\ \hline
\end{tabular}
\end{table}

\subsubsection{Block Diagram and Operation}
The \texttt{sin} module operates as follows:
\begin{enumerate}
    \item \textbf{Angle Adjustment:} The input angle $x$ is adjusted to $90^\circ - x$ to compute the sine using the cosine module.
    \item \textbf{Cosine Computation:} The adjusted angle is passed to the \texttt{cos} module, which computes the cosine value.
    \item \textbf{Output:} The result from the \texttt{cos} module is directly used as the sine value. The \texttt{done} signal is asserted to indicate the computation is complete.
\end{enumerate}

% \subsubsection{Flowchart}
% The flow of the \texttt{sin} module is illustrated in Figure~\ref{fig:sin_flowchart}.

% \begin{figure}[H]
% \centering
% \includegraphics[width=\textwidth]{images/sin_flowchart.pdf}
% \caption{Flowchart of the Sine Module}
% \label{fig:sin_flowchart}
% \end{figure}

\noindent By reusing the \texttt{cos} module, the \texttt{sin} module avoids duplicating the CORDIC core, saving hardware resources while maintaining computational efficiency.



% Subsection for Tangent
\newpage 
\subsection{Tangent}
\label{subsec:tangent}

The \texttt{tan} module computes the tangent of an input angle in degrees using the CORDIC algorithm. The module supports integer inputs in the range [-89°, 89°] and outputs the result in BFloat16 (BF16) format. Special cases such as $\tan(90^\circ)$ and $\tan(-90^\circ)$ are detected and flagged as errors.

\subsubsection{Inputs and Outputs}
The inputs and outputs of the module are described in Table~\ref{tab:tan_interface}.

\begin{table}[H]
\centering
\caption{Tangent Module Interface}
\label{tab:tan_interface}
\begin{tabular}{|c|c|c|p{8cm}|}
\hline
\textbf{Signal Name} & \textbf{Direction} & \textbf{Width} & \textbf{Description} \\ \hline
\texttt{clk}         & Input              & 1              & Clock signal for synchronization. \\ \hline
\texttt{rst}         & Input              & 1              & Reset signal to initialize the module. \\ \hline
\texttt{start}       & Input              & 1              & Start signal to initiate the computation. \\ \hline
\texttt{a}           & Input              & 16             & Signed integer input representing the angle in degrees. \\ \hline
\texttt{result}      & Output             & 16             & The computed tangent value in BF16 format. \\ \hline
\texttt{done}        & Output             & 1              & A signal indicating that the computation is complete. \\ \hline
\texttt{error}       & Output             & 1              & A flag indicating if an error occurred during computation. \\ \hline
\end{tabular}
\end{table}

\subsubsection{Flowchart}
The flow of the \texttt{tan} module is illustrated in Figure~\ref{fig:tan_flowchart}.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/tan.png}
\caption{Flowchart of the Tangent Module}
\label{fig:tan_flowchart}
\end{figure}

\subsubsection{Block Diagram and Operation}

The block diagram of the \texttt{tan} module is illustrated in Figure~\ref{fig:tan_sch}.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/tan_sch.png}
\caption{Block Diagram of the Tangent Module}
\label{fig:tan_sch}
\end{figure}

\noindent The tangent module operates as follows:
\begin{enumerate}
    \item \textbf{Input Validation:} The module checks if the input angle is $\pm90^\circ$. If so, the \texttt{error} signal is asserted, and the result is set to NaN.
    \item \textbf{Angle Reduction:} The input angle is reduced to the range [-90°, 90°] using modular arithmetic.
    \item \textbf{CORDIC Computation:} The reduced angle is passed to the CORDIC core, which computes both sine and cosine values in Q2.14 fixed-point format.
    \item \textbf{BF16 Conversion:} The sine and cosine values are converted from Q2.14 to BF16 format using dedicated conversion modules.
    \item \textbf{Division:} The tangent value is computed as $\tan(x) = \sin(x) / \cos(x)$ using a BF16 division module. If $\cos(x) = 0$, the \texttt{error} signal is asserted, and the result is set to NaN.
    \item \textbf{Output:} The \texttt{done} signal is asserted to indicate that the computation is complete, and the result is made available on the output.
\end{enumerate}

% \subsubsection{Flowchart}
% The flow of the \texttt{tan} module is illustrated in Figure~\ref{fig:tan_flowchart}.

% \begin{figure}[H]
% \centering
% \includegraphics[width=\textwidth]{images/tan_flowchart.pdf}
% \caption{Flowchart of the Tangent Module}
% \label{fig:tan_flowchart}
% \end{figure}

\noindent The module ensures efficient and accurate computation of tangent values, with robust handling of special cases and conversion to BF16 format.

% Subsection for Arctangent
\newpage 
\subsection{Arctangent}
\label{subsec:arctangent}

The \texttt{arctan} module computes the arctangent of an input integer slope in the range [-999, 999] and outputs the result in BFloat16 (BF16) format. The module uses the CORDIC algorithm in vectoring mode, with additional handling for large inputs that exceed the Q2.14 range.

\subsubsection{Inputs and Outputs}
The inputs and outputs of the module are described in Table~\ref{tab:arctan_interface}.

\begin{table}[H]
\centering
\caption{Arctangent Module Interface}
\label{tab:arctan_interface}
\begin{tabular}{|c|c|c|p{8cm}|}
\hline
\textbf{Signal Name} & \textbf{Direction} & \textbf{Width} & \textbf{Description} \\ \hline
\texttt{clk}         & Input              & 1              & Clock signal for synchronization. \\ \hline
\texttt{rst}         & Input              & 1              & Reset signal to initialize the module. \\ \hline
\texttt{start}       & Input              & 1              & Start signal to initiate the computation. \\ \hline
\texttt{a}           & Input              & 16             & Signed integer input slope. \\ \hline
\texttt{result}      & Output             & 16             & The computed arctangent in BF16 format. \\ \hline
\texttt{done}        & Output             & 1              & A signal indicating that the computation is complete. \\ \hline
\texttt{error}       & Output             & 1              & A flag indicating if the input is invalid. \\ \hline
\end{tabular}
\end{table}

\subsubsection{Flowchart}
The flow of the \texttt{arctan} module is illustrated in Figure~\ref{fig:arctan_flowchart}.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/arctan.png}
\caption{Flowchart of the Arctangent Module}
\label{fig:arctan_flowchart}
\end{figure}

\subsubsection{Block Diagram and Operation}

The block diagram of the \texttt{arctan} module is illustrated in Figure~\ref{fig:arctan_sch}.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/arctan_sch.png}
\caption{Block Diagram of the Arctangent Module}
\label{fig:arctan_sch}
\end{figure}

\noindent The \texttt{arctan} module operates as follows:
\begin{enumerate}
    \item \textbf{Input Validation:} The module checks if the input slope is within the valid range [-999, 999]. If the input is out of range, the \texttt{error} signal is asserted, and the result is set to NaN.
    \item \textbf{Special Cases:} The module directly returns precomputed BF16 values for the following cases:
    \begin{itemize}
        \item $\texttt{a} = -1$: $\arctan(-1) = -45^\circ$
        \item $\texttt{a} = 0$: $\arctan(0) = 0^\circ$
        \item $\texttt{a} = 1$: $\arctan(1) = 45^\circ$
    \end{itemize}
    \item \textbf{Divide-and-Conquer for Large Inputs:} For inputs with absolute value greater than 1, the module uses the identities:
    \[
    \arctan(a) = 90^\circ - \arctan\left(\frac{1}{a}\right) \quad \text{for } a > 1
    \]
    \[
    \arctan(a) = -90^\circ - \arctan\left(\frac{1}{a}\right) \quad \text{for } a < -1
    \]
    The reciprocal $\frac{1}{a}$ is computed in Q2.14 format, and the CORDIC core calculates $\arctan\left(\frac{1}{a}\right)$.
    \item \textbf{CORDIC Computation:} The module uses the CORDIC algorithm in vectoring mode to compute the arctangent of the input or its reciprocal. The algorithm performs 11 iterations to achieve a relative error of approximately 5\%.
    \item \textbf{BF16 Conversion:} The Q2.14 result is converted to BF16 format, including normalization, mantissa extraction, and exponent calculation.
    \item \textbf{Output:} The \texttt{done} signal is asserted to indicate that the computation is complete, and the result is made available on the output.
\end{enumerate}

% \subsubsection{Flowchart}
% The flow of the \texttt{arctan} module is illustrated in Figure~\ref{fig:arctan_flowchart}.

% \begin{figure}[H]
% \centering
% \includegraphics[width=\textwidth]{images/arctan_flowchart.pdf}
% \caption{Flowchart of the Arctangent Module}
% \label{fig:arctan_flowchart}
% \end{figure}

\noindent The module ensures efficient and accurate computation of arctangent values, with robust handling of large inputs and conversion to BF16 format.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage 
\subsection{Logarithm}
\label{subsec:logarithm}

The \texttt{log} module is designed to compute the logarithm of an input $b$ with respect to a base $a$ ($\log_a(b)$). It outputs the final result in BFloat16 (BF16) format. The module implements the mathematical change-of-base formula:
\[
\log_a(b) = \frac{\ln(b)}{\ln(a)}
\]
To achieve this without complex IP cores, it utilizes a sequential architecture that repurposes a single CORDIC core to calculate both natural logarithms ($\ln(b)$ and $\ln(a)$) before performing a fixed-point division (Reference: \url{https://docs.amd.com/r/en-US/ug958-vivado-sysgen-ref/CORDIC-LOG}).

\subsubsection{Inputs and Outputs}
The inputs and outputs of the module are described in Table~\ref{tab:log_interface}.

\begin{table}[H]
\centering
\caption{Logarithm Module Interface}
\label{tab:log_interface}
\begin{tabular}{|c|c|c|p{8cm}|}
\hline
\textbf{Signal Name} & \textbf{Direction} & \textbf{Width} & \textbf{Description} \\ \hline
\texttt{clk}         & Input              & 1              & Clock signal for synchronization. \\ \hline
\texttt{rst}         & Input              & 1              & Reset signal to initialize the module. \\ \hline
\texttt{start}       & Input              & 1              & Start signal to initiate the computation. \\ \hline
\texttt{a}           & Input              & 16             & Signed integer input representing the base. \\ \hline
\texttt{b}           & Input              & 16             & Signed integer input representing the value. \\ \hline
\texttt{result}      & Output             & 16             & The computed logarithm in BFloat16 format. \\ \hline
\texttt{done}        & Output             & 1              & A signal indicating that the computation is complete. \\ \hline
\texttt{error}       & Output             & 1              & A flag indicating if an error occurred during computation (e.g., invalid inputs). \\ \hline
\end{tabular}
\end{table}

\subsubsection{Flowchart}
The flow of the \texttt{log} module is illustrated in Figure~\ref{fig:log_flowchart}.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{images/log.png}
\caption{Flowchart of the Logarithm Module}
\label{fig:log_flowchart}
\end{figure}


\subsubsection{Block Diagram and Operation}

The block diagram of the \texttt{log} module is illustrated in Figure~\ref{fig:log_sch}.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/log_sch.png}
\caption{Block Diagram of the Logarithm Module}
\label{fig:log_sch}
\end{figure}

\noindent
The \texttt{log} module operates through a sequential finite state machine. The stages are described as follows:
\begin{enumerate}
    \item \textbf{Input Validation (S\_VALIDATE):} Ensures inputs are mathematically valid by rejecting non-positive values or a base of one.
    \item \textbf{Normalization (S\_PREP\_B, S\_PREP\_BASE):} Scales the inputs using a count-leading-zeros (CLZ) function and applies logarithmic identities to satisfy the convergence domain of the algorithm.
    \item \textbf{Hyperbolic CORDIC Computation (S\_CALC\_B, S\_CALC\_BASE):} Reuses a single logic core to calculate $\ln(b)$ and $\ln(a)$ over 16 iterations, explicitly repeating iterations 4 and 13 to guarantee convergence.
    \item \textbf{Bit-Serial Division (S\_DIV\_PREP, S\_DIV\_CALC):} Executes a 32-cycle restoring division algorithm to compute the final logarithm $\frac{\ln(b)}{\ln(a)}$.
    \item \textbf{Output Formatting (S\_CONVERT):} Translates the high-precision fixed-point result into BFloat16 format and asserts the \texttt{done} signal.
\end{enumerate}

\noindent The module also includes error handling to ensure that invalid inputs, such as non-positive values or a base of one, are flagged appropriately.

% filepath: c:\HKUST\ELEC4320\Proj\ELEC4320-Project\report\core_module.tex
\newpage 
\subsection{Exponential Operations}
\label{subsec:exponential_operations}

The \texttt{exp} module is designed to compute the exponential function $e^a$ for signed integer inputs, producing a BFloat16 (BF16) output. It utilizes a Finite State Machine (FSM) to orchestrate a hardware-efficient calculation based on the CORDIC algorithm in hyperbolic mode.

\subsubsection{Inputs and Outputs}
The inputs and outputs of the module are described in Table~\ref{tab:exp_interface}.

\begin{table}[H]
\centering
\caption{Exponential Module Interface}
\label{tab:exp_interface}
\begin{tabular}{|c|c|c|p{8cm}|}
\hline
\textbf{Signal Name} & \textbf{Direction} & \textbf{Width} & \textbf{Description} \\ \hline
\texttt{clk}         & Input              & 1              & Clock signal for synchronization. \\ \hline
\texttt{rst}         & Input              & 1              & Reset signal to initialize the module. \\ \hline
\texttt{start}       & Input              & 1              & Start signal to initiate the computation. \\ \hline
\texttt{a}           & Input              & 16             & Signed integer input representing the exponent. \\ \hline
\texttt{result}      & Output             & 16             & The computed exponential value in BFloat16 format. \\ \hline
\texttt{done}        & Output             & 1              & A signal indicating that the computation is complete. \\ \hline
\texttt{error}       & Output             & 1              & A flag indicating if an error occurred during computation (e.g., overflow or invalid input). \\ \hline
\end{tabular}
\end{table}

\subsubsection{Flowchart}
The flow of the \texttt{exp} module is illustrated in Figure~\ref{fig:exp_flowchart}.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/exp.png}
\caption{Flowchart of the Exponential Module}
\label{fig:exp_flowchart}
\end{figure}


\subsubsection{Block Diagram and Operation}

The block diagram of the \texttt{exp} module is illustrated in Figure~\ref{fig:exp_sch}.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/exp_sch.png}
\caption{Block Diagram of the Exponential Module}
\label{fig:exp_sch}
\end{figure}

\noindent
The \texttt{exp} module performs exponential calculations through a three-phase process managed by a finite state machine. The phases are described as follows:
\begin{enumerate}
    \item \textbf{Range Reduction (S\_REDUCE\_1, S\_REDUCE\_2):} The module handles large inputs by decomposing the value $a$ into an integer $k$ and a remainder $r$ using the identity:
    \[
    e^a = 2^k \cdot e^r
    \]
    This isolates the fractional exponent $e^r$ for calculation while storing $k$ for the final exponent adjustment.
    \item \textbf{Hyperbolic CORDIC Calculation (S\_CALC):} The module approximates $e^r$ by initializing vectors with a scaling constant and executing 16 iterations of shift-and-add operations. Iterations 4 and 13 are explicitly repeated to ensure convergence. The angle is updated using inverse hyperbolic tangent values stored in a ROM.
    \item \textbf{Normalization and Packing (S\_CONVERT):} The module derives the raw result from the vector sum $x + y$, normalizes the mantissa using a count-leading-zeros (CLZ) function, and calculates the final BFloat16 exponent by adding the stored integer $k$ to the standard bias. This effectively performs the multiplication by $2^k$ while handling overflow or underflow conditions.
\end{enumerate}

\noindent The module also includes error handling to ensure that invalid inputs, such as excessively large or small values, are flagged appropriately.


\newpage 
\subsection{Power}
\label{subsec:power}

The \texttt{pow} module is designed to calculate the power function $a^b$ for signed integer inputs, outputting the result in BFloat16 (BF16) format. Because calculating $a^b$ directly in digital logic is computationally prohibitive, this module implements the mathematical identity:
\[
a^b = e^{b \cdot \ln(a)}
\]
This approach effectively fuses a logarithm (using the CORDIC algorithm) and an exponential calculator into a single, unified pipeline.

\subsubsection{Inputs and Outputs}
The inputs and outputs of the module are described in Table~\ref{tab:pow_interface}.

\begin{table}[H]
\centering
\caption{Power Module Interface}
\label{tab:pow_interface}
\begin{tabular}{|c|c|c|p{8cm}|}
\hline
\textbf{Signal Name} & \textbf{Direction} & \textbf{Width} & \textbf{Description} \\ \hline
\texttt{clk}         & Input              & 1              & Clock signal for synchronization. \\ \hline
\texttt{rst}         & Input              & 1              & Reset signal to initialize the module. \\ \hline
\texttt{start}       & Input              & 1              & Start signal to initiate the computation. \\ \hline
\texttt{a}           & Input              & 16             & Signed integer input representing the base. \\ \hline
\texttt{b}           & Input              & 16             & Signed integer input representing the exponent. \\ \hline
\texttt{result}      & Output             & 16             & The computed power value in BFloat16 format. \\ \hline
\texttt{done}        & Output             & 1              & A signal indicating that the computation is complete. \\ \hline
\texttt{error}       & Output             & 1              & A flag indicating if an error occurred during computation (e.g., invalid inputs). \\ \hline
\end{tabular}
\end{table}

\subsubsection{Flowchart}
The flow of the \texttt{pow} module is illustrated in Figure~\ref{fig:pow_flowchart}.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/pow.png}
\caption{Flowchart of the Power Module}
\label{fig:pow_flowchart}
\end{figure}


\subsubsection{Block Diagram and Operation}

The block diagram of the \texttt{pow} module is illustrated in Figure~\ref{fig:pow_sch}.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/pow_sch.png}
\caption{Block Diagram of the Power Module}
\label{fig:pow_sch}
\end{figure}

\noindent

The \texttt{pow} module operates through a sophisticated five-phase Finite State Machine (FSM) to compute powers using the logarithmic identity $a^b = e^{b \ln a}$. The phases are described as follows:
\begin{enumerate}
    \item \textbf{Input Validation (S\_VALIDATE):} Handles edge cases, such as returning 1 when the exponent is 0 or erroring on invalid negative bases. The result's sign is determined based on the exponent's parity.
    \item \textbf{Logarithm Calculation:} Normalizes the base using a count-leading-zeros (CLZ) function and employs a hyperbolic CORDIC algorithm over 16 iterations to compute $\ln |a|$.
    \item \textbf{Multiplication (S\_MULT\_1, S\_MULT\_2):} Calculates the intermediate exponent $P = b \cdot \ln a$. This operation is split into two states to provide a clean timing path for the DSP blocks.
    \item \textbf{Exponential Calculation:} Utilizes range reduction to decompose $P$ into an integer $k$ and remainder $r$, allowing:
    \[
    e^P = e^r \cdot 2^k
    \]
    The module reuses the CORDIC logic in rotation mode to compute $e^r$.
    \item \textbf{Normalization and Packing (S\_CONVERT):} Constructs the BF16 output by normalizing the mantissa, adjusting the biased exponent by the integer $k$, and handling overflows by setting the result to infinity.
\end{enumerate}

\noindent The module also includes error handling to ensure that invalid inputs, such as negative bases with non-integer exponents, are flagged appropriately.







% Subsection for Factorial
\newpage 
\subsection{Factorial}
\label{subsec:factorial}

The \texttt{fac} module computes the factorial of an integer input using an iterative multiplication approach. The module supports integer inputs in the range [0, 12] and outputs the result in BFloat16 (BF16) format. Inputs outside this range are flagged as errors.

\subsubsection{Inputs and Outputs}
The inputs and outputs of the module are described in Table~\ref{tab:fac_interface}.

\begin{table}[H]
\centering
\caption{Factorial Module Interface}
\label{tab:fac_interface}
\begin{tabular}{|c|c|c|p{8cm}|}
\hline
\textbf{Signal Name} & \textbf{Direction} & \textbf{Width} & \textbf{Description} \\ \hline
\texttt{clk}         & Input              & 1              & Clock signal for synchronization. \\ \hline
\texttt{rst}         & Input              & 1              & Reset signal to initialize the module. \\ \hline
\texttt{start}       & Input              & 1              & Start signal to initiate the computation. \\ \hline
\texttt{a}           & Input              & 16             & Signed integer input. \\ \hline
\texttt{result}      & Output             & 16             & The computed factorial in BFloat16 format. \\ \hline
\texttt{done}        & Output             & 1              & A signal indicating that the computation is complete. \\ \hline
\texttt{error}       & Output             & 1              & A flag indicating if the input is invalid. \\ \hline
\end{tabular}
\end{table}

\subsubsection{Flowchart}
The flow of the \texttt{fac} module is illustrated in Figure~\ref{fig:fac_flowchart}.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/fac.png}
\caption{Flowchart of the Factorial Module}
\label{fig:fac_flowchart}
\end{figure}

\subsubsection{Block Diagram and Operation}

The block diagram of the \texttt{fac} module is illustrated in Figure~\ref{fig:fac_sch}.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/fac_sch.png}
\caption{Block Diagram of the Factorial Module}
\label{fig:fac_sch}
\end{figure}

\noindent The \texttt{fac} module operates as follows:
\begin{enumerate}
    \item \textbf{Input Validation:} The module checks if the input is within the valid range [0, 12]. If the input is negative or greater than 12, the \texttt{error} signal is asserted, and the computation is aborted.
    \item \textbf{Factorial Computation:} For valid inputs, the module iteratively multiplies integers from 1 to the input value using a 32-bit unsigned accumulator.
    \item \textbf{BF16 Conversion:} The computed factorial is converted to BF16 format using a normalization process that extracts the sign, exponent, and mantissa.
    \item \textbf{Output:} The \texttt{done} signal is asserted to indicate that the computation is complete, and the result is made available on the output.
\end{enumerate}

% \subsubsection{Flowchart}
% The flow of the \texttt{fac} module is illustrated in Figure~\ref{fig:fac_flowchart}.

% \begin{figure}[H]
% \centering
% \includegraphics[width=\textwidth]{images/fac_flowchart.pdf}
% \caption{Flowchart of the Factorial Module}
% \label{fig:fac_flowchart}
% \end{figure}
